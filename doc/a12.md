# A12

A12 is a remote network protocol for interactive, realtime multimedia
applications. It is has been designed as the network equivalent of the local
display server API and IPC system, SHMIF [ref:shmif], used by the Arcan
project[ref:arcan]. To achieve this it adds extensions for supporting
confidentiality, integrity, discovery and adaptive compression.

This document provides an informal introduction for implementing and using the
protocol and document its security considerations, along with an overview of
the existing tools and support libraries that exist to leverage it today.

## Table Of Contents

1. [Introduction](#introduction)
2. [Dependencies](#dependencies)
3. [Authentication and Cryptography](#authentication-and-cryptography)
4. [Commands](#commands)
5. [Streaming Transfers](#streaming-transfers)
    2. [Video](#video)
    3. [Audio](#audio)
    4. [Binary](#binary)
    5. [Text](#text)
6. [Event Model](#event-model)
    1. [Input](#input)
    2. [Target Commands](#target-commands)
    3. [External Hints](#external-hints)
7. [Example Flow and Lifecycle](#flow)
8. [Directory Extension](#directory-extension)
    2. [File Transfer](#directory-file)
    3. [FAP Format](#directory-fap)
9. [Discovery Extension](#discovery-extension)
10. [Security](#security)
11. [Tools and Reference Implementations](#tools-and-reference-implementations)
12. [Future Changes](#future-changes)
13. [Acknowledgements](#acknowledgements)
14. [References](#references)

# Introduction

Related protocols: RFB/VNC, SSH,
Source, Sink, Directory (optional).

# Dependencies

Many of the primitives used are from other established algorithms and protocols.
The dependencies that MUST be present are:

X25519[ref:x25519] for public key. ChaCha[ref:chacha] for stream cipher.
Blake3[ref:blake3] used for HMAC construction, key derivation, hashing for
cache management and integrity. Zstd[ref:zstd] for generic compression.

It is also RECOMMENDED that H264[ref:h264] is present for video compression,
and Ed25519[ref:ed25519] for message signatures, but an implementation MUST
provide work-arounds for their absence.

All integral types are in network byte order.

# Authentication and Cryptography

Every packet except for the first has the same outer frame format:

    |--------------------------|
    | 16 octet MAC             |
    |--------------------------| ---
    | 8 byte sequence number   |  |
    | 1 byte type              |  |   encrypted
    |--------------------------|  |
    | [ type dependent block ] |  |
    |--------------------------| ---

The first packet has the MAC truncated to 8 octets, and an 8 octet
cryptographically secure pseudorandom number used as a nonce for key
derivation.

The are 5 possible packet types, covered in their respective sections:

    Control Command (1) in [Section 4, Commands](#commands).
    Event (2) in [Section 6, Event Model](#event-model).
    Video Data (3), Audio Data (4), Binary Data (5) in
    [Section 5](#streaming-transfers).

## Key Derivation

The key derivation used for the authentication packet is as follows:

    kA   = H(message = 'arcan-a12 init-packet', passphrase, nonce)
    kMac = H(kA)
    kCl  = H(kMac)
    kSrv = H(kCl)

Reference: HKDF specification.

This is performed using BLAKE3 in KDF mode.

Unless another passphrase has been agreed upon, it MUST be set to the default
'SETECASTRONOMY'. In controlled environments where there is a pre-existing
secure communication channel, the passphrase can be swapped to a limited use
one as needed.

When using a 3rd party rendezvous to establish a connection between a source
and a sink, the 3rd party will generate one in order for the two to
authenticate the public keys used. See the 'Directory extension' section for
this.

kMac is used to calculate the MAC for each packet according to:

    MAC = H(previous_MAC | packet_octets)

with packet\_octets starting after the MAC field of the packet and continuing
through the length of the packet.

Each side initiates the ChaCha8 state machine using the tuple {kCl, nonce} for
the client end, and the server end for {kSrv, nonce}.

The reason this setup is used before initiating actual key exchange and
derivation according to x25519 is to ensure that there is no reliable
fingerprint in the initial packet exchange, as well as for enabling the
passphrase preauthentication of unknown public keys.

Before a connection is completely authenticated, the only packet type MUST be
'Control' (=1). It is the only packet type accepted in a preauthenticated
state. See the control section for details on its general structure.

The first command sent, first from client to server with a matching reply
from server to client is 'HELLO' (=0). The fields used are as follows:

    version-major: u8
    version-minor: u8
    mode: u8
    kpub: u8[32]
    role: u8
    petname: u8[16]

The version fields should be pegged to the corresponding version of the
arcan-shmif build, if present, to assist with debugging the other end. In the
final release of this protocol the version will be set to 1 major 0 minor and
bumped should any critical change be necessary after the fact.

The'mode' field specifies the authentication mode desired, and MUST be one of
the following:

    0, no-exchange. Keep using the current derived keys for all communication.
       This is NOT RECOMMENDED unless mandated by the legal environment.

    1, x25519-direct. Start x25519 exchange using the provided kpub.
       The other end will respond in kind.

    2, x25519-ephemeral. The public key provided is a temporary one.

To further explain the x25519-ephemeral mode, the purpose is to establish a
more secure channel before transmitting the actual public keys in order to
force an aggressor to actively perform a man in the middle attack to harvest
the actual public keys for tracking.

Both sides will temporarily treat the other ephemeral key as known, then
transition the mode to x25519 (=1) and repeat the HELLO command, this time with
the actual intended public keys.

The 'role' can be set to either:
    1 = source,
    2 = sink,
    3 = probe,
    4 = directory.

PROBE and DIRECTORY are specifically used for "Directory Extension" mode
covered in Section 8. Connecting a Source to a Source or a Sink to a Sink
MUST be prohibited and result in connection shutdown.

## Rekeying

After a successfully authenticated connection, the server end holds 'rekeying'
ownership. The current owner may, at any time, issue a REKEY command,
transferring ownership of the REKEY commmand over to the other end.

To do this, the owner first generates a new ephemeral X25519 keypair and passes
the new public key as payload to the REKEY command together with a nonce in the
entropy part of the command header. It sends this packets then rotate keys for
outbound use.

The new shared secret is calculated using the new private key together with the
last known public key of the other nedpoint. The outbound cipher and HMAC state
is reset to this together with the nonce attached to the command packet.

The new MAC key is taken from H(message = 'arcan-a12 rekey', shared secret).

It is RECOMMENDED that the server performs the initial REKEY early, and that
further passing of the REKEY back and forth is latched to some trigger, e.g.
after a certain number of bytes of cipherstream has been consumed.

After a REKEY, old keymaterial MUST be discarded safely. The easiest way to do
this is to generate the new keymaterial and hasher/cipher state into the same
memory that the old material consumed.

# Commands

Every control packet type has a fixed size of 128 octets, with any extra
octets padded with noise or zero.

The fields of a control packet are as follows:

      -----------------------
       last-seen : u64
       entropy   : u8[8]
       ch-id     : u8
       command   : u8
      -----------------------
       command-specific data
      -----------------------

Last-seen provides the sequence number of the latest seen packet from the other
end, or zero if no packet has yet to be received. The drift window (last-sent -
last-seen) SHOULD inform encoding heuristics and latency compensation.

Entropy is 8 octets of cryptographically secure pseudorandom numbers.

Channel-id is set to the active channel that the command applies to, which
will be zero unless aditional channels have been negotiated. The command
value and command specific fields whill be covered in the remainder of this
section.

If the channel referenced by ID is invalid and refer to a previously closed
channel, the command should be discarded and processing continue as normal.

## Command 0: HELLO

This command was covered in Section 3, "Authentication and Cryptography".

## Command 1: SHUTDOWN

    last-words : u8[32]

This terminates a channel with an optional short message describing the reason
for termination, if any.

## Command 2 : DEFINE-CHANNEL

    id        : u8
    type      : u8
    direction : u8

This creates another communication channel. Every channel can be a recipient of
commands, and may contain between zero and three ongoing data streams: one for
video, one for audio and one for binary. Audio and Video are unidirectional and
direction established on channel allocation.

Channel allocation SHOULD be paired to- and triggered- by secondary events from
user interaction and, while possible, not expected to be called arbitrarily.

Because of these secondary events (see Section 6. Event Model) there is no
provision for collision avoidance in channel allocation, should both sides
decide to define the same channel identifier within a collision window.

It is RECOMMENDED to split the ID namespace such that source uses odd number
identifiers and sink uses even number ones but it is merely as a precaution.

## Command 3 : STREAM-CANCEL

    id     : u32
    reason : u8
    type   : u8

This cancels an ongoing stream on the channel. Id carries the identifier
provided in the corresponding DEFINE-A,-B-,V-STREAM command. Reason can
be:

    0 - Undesired

The sink is no-longer interested in the contents of the stream and the source
MUST stop sending over the channel as soon as this command is received.

    1 - Unhandled Format

The sink is not capable to decoding stream contents due to an incompatibility
with the encoding scheme present. This can happen at any point during decoding.
The source SHOULD attempt to re-open the stream with a more compatible codec,
even if this might be raw pixel streams deltas compressed with the REQUIRED
Zstd compression option.

    2 - Already Known

The source already has the contents of the stream available locally. This is a
possible outcome for certain binary transfers of assets that can persist across
connections, such as files used for text typeface.

## Command 4 : DEFINE-VIDEO-STREAM

This command is described in [Section 5.2, Video](#video).

## Command 5 : DEFINE-AUDIO-STREAM

This command is described in [Section 5.3, Audio](#audio).

## Command 6 : DEFINE-BINARY-STREAM

This command is described in [Section 5.4, Binary](#binary).

## Command 7 : PING

    stream-id : u32

This command can be used by either source sink for a channel and it is
RECOMMENDED that it is sent periodically both as connection keep-alive and to
assist each side with congestion window size tracking. The stream ID field
reference the last known completed stream, if any.


## Command 8 : REKEY

This command is described in [Section 3, Authentication](#authentication-and-encryption).

## Command 9 .. 14 : DIRECTORY EXTENSION

These command numbers are reserved for the directory extension. Their values
and use are described in [ref:Section 8].

# Streaming Transfers

As covered in COMMAND 2, DEFINE CHANNEL - each channel is a container for one
unidirectional audio stream, one unidirection video stream and one
bidirectional binary stream. To initiate a stream on a channel, the apropriate
end issues a corresponding DEFINE-VIDEO-STREAM, DEFINE-AUDIO-STREAM or
DEFINE-BINARY-STREAM commands, followed by interleaving data packets of the
same type.

The data packets (3 VSTREAM-DATA, 4 ASTREAM-DATA, 5 BSTREAM-DATA) all have
the same header fields:

   channel-id : u8
   stream-id  : u32
   length     : u16

followed by 'length' variable number of continous bytes to expect. It is the
full header+variable data block that is used to calculate and verify the
message authentication code as per [3. Authentication and
Encryption](#authentication-and-encryption).

The implementation may implement a number of strategies for chunking and
interleaving a stream, informed by current congestion window size, abstract
window type and event flow.

## Video

A video frame transfer is initiated with a DEFINE-VIDEO-STREAM command (4),
followed by a number of vstream data packets (packet type 3). It is recommended
that those data packets are interleaved with other ongoing stream and command
transfers, with priority given to the channel with most recent user interaction
and activity focus through the VIEWPORT event (see [Section 6](Event Model)).

The fields of the 'DEFINE-VIDEO-STREAM' command are as follows:

    id                : u32
    format            : u8
    surface width     : u16
    surface height    : u16
    x                 : u16
    y                 : u16
    frame width       : u16
    frame height      : u16
    flags             : u8
    compressed size   : u32
    uncompressed size : u32
    commit            : u8
    four-cc           : u8[4]

ID is a source defined identifier. It is local to the channel the stream is
being defined on and MUST not collide with other streams defineed on the same
channel. It is RECOMMENDED that this is tracked locally per channel and
incremented each time a stream is defined. An implementation MUST NOT permit
multiple streams of the same type in flight without being explicitly cancelled.

A single stream can be used to convey a number of image frames, and only need
to be redefined if the dimensions of the backing store change.

Format defines the encoding method for the data being sent:
    0 : 32-bit, R8G8B8A8 with linear alpha.
    1 : 24-bit, linear full-opqaue R8G8B8
    2 : 16-bit, linear R5G6B5
    5 : H264 stream
    7 : ZSTD compressed TPACK block
    8 : ZSTD compressed full frame
    9 : ZSTD compressed delta frame
    10 : Passthrough stream

The 3,4,6 format values are deprecated but kept allocated to retain
compatibility with dated implementations still using them. It is RECOMMENDED
that any encountered unhandled format value triggers a STREAM-CANCEL command
with unhandled format (1) as reason for cancellation.

The 'TPACK' format is described in [Section 5.5, Text](#text).

If format is set to passthrough (10) the four-cc field SHOULD contain the
fourCC encoded identifier of the encoder type, if known. This is used to permit
an opaque bitstream link with hardware encoders where the protocol
implementation might lack access to specifics due to hardware, security and
architectural segmentation.

All region and surface dimensions are in upper-left origo buffer order.

These are further modified by the 'flags' bitmap of possible processing hints:

    1 : origo-lower-left

This bit is set if the decompressed buffer has an inverted row order and should
be flipped later in the processing pipeline.

If the format is of the known raw (0,1,2) or compressed raw(8,9) types the x,
y, frame width and frame height fields specify the affected region of the
defined surface. Multiple updates can be sent in sequence and changes
accumulate at the receiving sink end. Updates MUST NOT be passed on locally
until a stream with the 'commit' field is set to a non-zero value.

An implementation MUST calculate the uncompressed size based on the format and
surface dimensions and compare the calculated uncompressed size against the
value presented in the received size before allocating any decompression buffer
space and reject by issuing a CANCEL-STREAM command if the calculated value
does not match the received one.

## Audio

An audio frame transfer is initiated with a DEFINE-AUDIO-STREAM command (5),
followed by a number of astream data packets (packet type 4).

The fields of the 'DEFINE-AUDIO-STREAM' command are as follows:

    id                : u32
    channels          : u8
    encoding          : u8
    nsamples          : u16
    rate              : u32

The following encodings are supported:

    signed 16-bit (0)

## Binary

A binary 'blob' transfer is initiated with a DEFINE-BINARY-STREAM command (6),
followed by a number of bstream data packets (packet type 5).

The fields of the 'DEFINE-BINARY-STREAM' command are as follows:

    stream-id         : u32
    size              : u64
    type              : u8
    token-id          : u32
    checksum          : u8[16]
    compressed        : u8

Stream identifier shares namespace with audio and video streams. It MUST be
unique. It is SUGGESTED that they are allocated through a shared incremental
counter.

The size field covers how many bytes that should be transferred in total,
or 0 if the stream is continuous. For that case completion and progress
notification is conveyed over the STREAMSTATUS event.

The type MUST be one of the following:

    state (0)           event trigger: STATE-IN, STATE-OUT
    bchunk (1)          event trigger: BCHUNKSTATE, BCHUNK-IN, BCHUNK-OUT
    font (2)            event trigger: FONTHINT
    font-secondary (3)  event trigger: FONTHINT
    debug (4)
    appl (5), appl-controller (6) (See DIRECTORY extension)

The token ID is a custom identifier used to pair the ongoing stream with queued
event with the outer desktop.

The checksum, if known, should use BLAKE3 in unkeyed hash mode. Its purpose is
for the other end to check for a locally cached version, and issue a
CANCEL-STREAM command if a matching one exists.

## Text

A channel can be used to provide formatted text as a special encoded 'TPACK'
video stream. These are always compressed with ZSTD and values encoded in
little- endian.

Each frame starts with a 16 octet frame header:

    data-size        : u32
    line-count       : u16
    cell-count       : u16
    scroll-direction : u8
    frame-flags      : u16
    background-colour: u8[4]
    cursor-state     : u8

Each line contains:

    start-line       : u16
    cell-count       : u16
    cell-offset      : u16
    content-dir      : u8 ?!
    scroll-dir       : u8 ?!
    line-state       : u8

Followed by cell-count of cells:

 * 3 bytes front_color
 * 3 bytes back_color
 * 2 byte  attribute bitmap
 * 4 bytes glyph-index or ucs4 code

* attribute bits (byte 0)
 * bit 0: bold
 * bit 1: underline
 * bit 2: underwave
 * bit 3: italic
 * bit 4: strikethrough
 * bit 5: cursor
 * bit 6: shape break (re-align to grid)
 * bit 7: skip-bit (double-width)
 *
 * (byte 1)
 * bit 0: glyph-index
 * bit 1: glyph-index-alt-font
 * bit 2: border-right
 * bit 3: border-down
 * bit 4: border-left
 * bit 5: border-top
 * bit 6: treat color as palette reference (first byte of front_color)

# Event Model

Event type packets have a fixed 128 byte sized. The categories and types are
selected as a filtered subset of those present in [ref:SHMIF]. Naming and
numbering conventions are kept to match compatibility as close as possible with
existing consumers of SHMIF.

Each packet has a 1 byte category selector:

    category : u8

The PERMITTED category values are:

    input-device (2),
    target-command (16),
    external-hint (64).

An implementation MUST block/warn, discard/warn or terminate if a value from a
non-permitted category is found as this suggests a routing or filtering issue
with other users of SHMIF.

## Input

Event category 2 is used for input events. This is most commonly provided when
a user is interacting with a window that has been provided over a channel.

These have a frame format of:

    input-kind     : u32
    device-kind    : u32
    datatype       : u32
    label          : u8[16]
    flags          : u8
    device-id      : u16
    device-subid   : u16
    segment-token  : u32
    sample-ts      : u64

Input kind and Device- kind are hints as to device and sampling origin, with
datatype specifying layout of remaining bytes in event packet.

Input kind MUST be one of the following values:

    button      : 0
    axis-motion : 1
    touch       : 2
    status      : 3
    eyes        : 4

Device kind MUST be one of the following values:

    keyboard        : 1
    mouse           : 2
    game-controller : 4
    touch-display   : 8
    led-controller  : 16
    eyetracker      : 32
    status          : 64

These are laid out as a bitmask both for internal routing uses, and the
INPUTMASK events that can be used to disable forwarding of several device
categories.

The label is a custom, short, ASCII encoded tag. This is used to pair with
LABELHINT events sent by the source in order to convey suggested binding and to
allow outer windowing system to reliably rebind or reroute.

Flags is a bitmap used to indicate if the event sample is associated with input
access or routing entering (& 2), leaving (& 4) a surface active state or
gesture (& 1).

Device ID is a source-local non-unique identifier to distinguish between one
device or another, and subid for devices with multiple associated input
sources.

The segment token is normally set to zero, but can be used to reference a
segment bound on some channel when manually rerouting, forwarding or
synthesizing input events.

The sample-ts timestamp is a monotonic clock in microseconds updated when the
sample was generated, for comparison against previous samples from the same
channel.

If the datatype is specified as ANALOG (=1):
   relative : u8
   count    : u8
   samples  : d16[4]

Relative defines if the values provided in samples are relative to their
previously defined value (starting at 0), count how many (MUST be larger than
zero and less than- or equal to- 4).

If the datatype is specified as DIGITAL (=2):
   active : u8

If active is set to 1, means that the button is being held and 0 if it has been
released.

If the datatype is specified as TRANSLATED (=4):

   codepoint : u8[5]
   active    : u8
   scancode  : u8
   symbol    : u32
   modifers  : u16

Codepoint refers to a single, 0 terminated UTF-8 encoded unicode codepoint, or
zero if there is no available translation for the event.

If active set to 1, the translated input has been activated (rising) or released
(falling).

The scancode is a device-defined reference for the button input which triggered
the event.

The symbol is a segment type relative lookup table index.

Modifiers is a bitmask, with the following bit allocation:

   LEFT-SHIFT    : 1
   RIGHT-SHIFT   : 2
   LEFT-CONTROL  : 3
   RIGHT-CONTROL : 4
   LEFT-ALT      : 5
   RIGHT-ALT     : 6
   LEFT-META     : 7
   RIGHT-META    : 8
   NUMLOCK       : 9
   CAPSLOCK      : 10
   MODE          : 11
   REPEAT        : 12

The REPEAT modifier indicates that the event is an oscillating input and the
timestamp/congestion state SHOULD be considered before forwarding in order to
avoid accidental oscillations due to network conditions.

If the datatype is specified as TOUCH (=8):
   active         : u8
   x, y           : d16
   pressure, size : f32
   tilt-x, tilt-y : d16
   tool           : u8

If the datatype is specified as EYES (=16):
   head position  : f32[3]
   head angle     : f32[3]
   gaze-region    : f32[4]
   user-present   : u8

## Target Commands

Target commands are authoritate instructions flowing from sink to source. Their
numbering and allocations have evolved organically, with gaps in event value
caused by deprecation or being masked due to poor translation from a local to
network processing model. Values not present in this set MUST transition the
connection to a terminal state.

EXIT (1)

The exit command means that the channel will be severed. No further
event processing will be considered in either direction. This
SHOULD result in a COMMAND-CLOSE on the channel.

FRAMESKIP (2)

s32 - framecount.

STEPFRAME (3)

s32 - frames
s32 - clock ID
u32 - MSC

RESET (9)

s32 - state
      0 : 'soft'
      1 : 'hard'
      2 : 'recovery'
      3 : 'reconnect'

PAUSE (10)
UNPAUSE (11)

SEEKTIME 12)

s32 : relative or absolute
f32 : timestamp (ms)

SEEKCONTENT (13)

scrolling
s32 : relative or absolute
relative :
 d32 : dy
 d32 : dx
 d32 : dz

absolute:
 f32 : x, 0..1 - percentage
 f32 : y, 0..1
 f32 : z, 0..1

DISPLAYHINT (14)

 d32 : width
 d32 : height
 d32 : hint (0 normal, 1 drag, 2 invisible, 4 unfocused, 8 maximized, 16 fullscreen, 32, detached
 d32 : layout ( rgb, bgr, vrgb, vbgr )
 f32 : ppcm
 d32 : cell-width
 d32 : cell-height
 d64 : segment token

STREAMSET (16)
 d32: steam identifier

ATTENUATE (17)
 f32: 0..1 gain

NEWSEGMENT (19)
NOPASS, synthesise on new channel being defined.

REQFAIL (20)
 u32: cookie

GRAPHMODE (23)
 u32: group (1..7, &256 for background bit)
 f32: r, g, b (0..255)

MESSAGE (24)
 u8: [78]

FONTHINT (25)
 f32: font size in mm (0 = unchanged)
 d32: hint (0ff, mono, light, medium)
 d32: continuation

sideband through bchunk

GEOHINT (26)

 f32: lat, long, lelev, (uu[3] 3166-1 alpha 4 country,
      639-2, spoken lang, 639-2 u[3] written)

OUTPUTHINT (27)

 d32: max_w
 d32: max_h
 d32: hz
 d32 = min_width
 d32 : output_id,
 fv : vrr min
 fv : vrr step

ACTIVATE (28)

no arg

ANCHORHINT (30)

 s32: rel_x
 s32: rel_y
 s32: rel_z,
 d64: source
 d64: parent
 d32: idtype (exterma; !segtok)

## External Hints

External events are descriptive events from source to sink. They MAY affect
behaviour on sink processing, but any actions are implementation- defined.
Values not present in this set MUST transition the connection to a terminal
state.

MESSAGE (0)
IDENT (2)
FAILURE (3)
BUFFERSTREAM (4)
FRAMESTATUS (5)
STREAMINFO (6)
STREAMSTATUS (7)
STATESIZE (8)
FLUSH-AUDIO (9)
SEGMENT-REQUEST (10)
CURSORHINT (12)
VIEWPORT (13)
CONTENT-STATE (14)
LABELHINT (15)
REGISTER (16)
ALERT (17)
CLOCKREQ (18)
BCHUNKSTATE (19)
INPUTMASK (22)

# Directory Extension

The 'role' specified during authentication can, as mentioned, be source, sink,
probe or directory. The directory one is an extension to the base protocol
which adds alternate context interpretation of some events, as well as adding a
handful of new commands.

This extension is experimental, and some commands may be modified with
revisions to this document.

The purpose of the directory is to work as rendezvous for discovery, state
storage, transform and messsaging for your fleet of a12 capable clients.

A client connected to a directory with the 'sink' role MAY be permitted to
list as an available data sink. Consequently, a client connected with the
'source' role MAY be permitted to list as an available data source.

A client connected as probe may use the LIST command (9):

  notify : u8

If notify is set to 1, the directory MAY send updates to the index of available
directory resources at any time.

The directory server SHOULD reply to a LIST with zero or more DIRECTORY-STATE
(10) and zero or more DIRECTORY-DISCOVER (11) commands.

DIRECTORY-STATE (10) contains the following fields:

  identifier: u16
  reserved-1: u16
  reserved-2: u16
  checksum: u8[4]
  size: u64
  name: u8[16]
  description: u8[94]

Identifier is a directory- local identifier for an appl. An Appl is a set of
Lua scripts and ancilliary resources packaged according to the FAP format
below. The Identifier (0) is reserved and it is RECOMMENDED that the directory
allocate identifiers incrementally from 1 and onwards for available appls.

DIRECTORY-DISCOVER (11) contains the following fields:

  role: u8
  state: u8
  petname: u8[16]
  public-key: u8[32]

With role indicating 0 for a source, 1 for a sink and 2 for a linked directory.
The state field is set to 0 if the entity has been added, and 1 if it
has been removed.

The petname match the petname provided when the other end negotiated its
connection as per the HELLO command. It is possible for the directory to
provide multiple entries for the same petname using different public-keys. This
is useful when there is on-demand load balancing provisioning of sources.

To access an announced source or sink, the DIRECTORY-OPEN (12) command can
be used:

  mode: u8
  public-key: u8[32]

This requests that the directory server provides a connection to the source,
sink or linked directory with a public key the one provided. Three different
modes are supported and can be provided as a bitmap.

 1 = inbound, 2 = outbound, 4 = tunnel.

The mode chosen depends on reachability of the two endpoints and the selection
is up to the discretion of the directory implementation. Of particular note is
the 4th mode where the pre-existing directory connection will be used to tunnel
a connection between the two.

The directory server MUST respond to an OPEN command with a 'DIRECTORY-OPENED'
command (13). This command carries the following fields:

    status : u8
    address : u8[46]
    port : u16
    secret : u8[12]
    public-key : u8[32]

Status can be one of:

    0 indicating failure
    1 direct inbound connection
    2 direct outbound connection
    3 tunnel

The connection can fail (status = 0) if there is no negotiable solution
for the two endpoints to reach eachother, or if the one or the other has
disconnected while the request was made.

The address field will carry an ascii encoded IPv4 or IPv6 address in the case
of an inbound or outbound connection, or a directory- local tunnel ID if the
directory server will act as a tunnel.

The provided public-key is the key the other end will use to initiate the
connection, and the secret will be used as passphrase for authenticating the
initial HELLO command. The directory MUST use a UNIQUE cryptographically secure
pseurandom number generator for generating the secret.

The negotiated tunnel identifier corresponds to a channel, and transfers
to/from the other end comes as a BINARY packets across that channel. Any
other activity on that channel MUST be ignored.

To terminate a tunnel relay session, either of the three parties (SOURCE, SINK,
DIRECTORY) issues a DROP-TUNNEL (14) command with the matching identifier as
the payload.

## File Transfer

The DEFINE-BINARY-STREAM command is used to initiate a binary transfer as per
[Section 5.4, Binary](#binary). For regular file transfers, the pairing event
used to transfer metadata and as a trigger for creating the stream is
BCHUNKSTATE, which MUST carry a namespace selection identifier, a request
identifier, a unique name as the 'extensions' part of the event and desired
direction.

The namespace identifier corresponds to (0 = private) or a valid APPLID
provided as a response or notification following the LIST command. Any name
starting with a dot '.' is reserved for protocol use.

The name '.index' SHALL be used to transfer a list of files available in the
namespace. The format for the .index is encoded as a number of line separated
entries using UTF-8 encoded key[=value] with : as separator between keys.

If a requested name does not exist (for download), or there is insufficient
permission (for upload or download), the directory server MUST respond with a
TARGET\_COMMAND\_REQFAIL event with the corresponding request identifier.

If the request is permitted, the directory server MUST initiate the transfer
through the DEFINE-BINARY-STREAM command.

The reserved '.appl' name is reserved for accessing the directory server appl
store in order to retrieve or update the client side portion of an appl.

## FAP format

FAP - (Format, Arcan, Package) is used to package an appl as desribed in the
DIRECTORY-STATE command. These use the same key/value encoding scheme as with
.index files, where each entry MUST contain a 'path' key, a 'name' key and
a 'size' key.

The 'size' key value MUST be set to a string encoded value of the number of
bytes belonging to path/name to consume from the bytestream unencoded. This
will be followed by a new entry until there are no more bytes left to consume.

# Discovery Extension

A12 has an optional broadcast domain discovery protocol. It is intended to work
inside the message domain of a network of directory servers, in the broadcast
domain of an IPv4 network and multicast domain of an IPv6 network.

Discovery here means establishing a network path to an entity where a previous
authenticated relationship exists. The entity that should be 'discovered'
issues a beacon, and entities that should affirm knowledge of this entity
replies to a beacon given certain prerequisites.

## Beacon

The beacon follows the format of an 8 byte NONCE which comes from a CSPRNG
source combined with a set of X25519 public keys that are NONCE, H(NONCE, Kpub)
stacked together.

The beacon is sent in the broadcast domain, wait for 1 second then send a
beacon as (NONCE+1, H(NONCE + 1, Kpub1) .. H(NONCE, Kpub..n)). This provides a
'proof of elapsed time' that is more expensive for the source of the beacon to
calculate, than for the recipient to verify.

The recipient of a beacon sweeps its keystore, looking for matches to H(NONCE,
Kpub) to pair to a known petname-Kpub pair.

A number of Kpub identities can be packed in the same beacon as the
authentication setup and reference tooling encourages differentiation of
multiple keypairs to one identity.

## Beacon Response

A device that sees a valid beacon pair with a valid timeout checks its known
keystore and calculates H(NONCE, Kpub) for a match. If there is one, it
calculates the H(NONCE, Self.Kpub) for the public key used to establish the
identity in the past to the device in question.

It sweeps the keystore for any Kpub that match, and can use that to initiate
a direct connection and/or alert outer user interfaces that the paired petname
has been discovered.

This scheme ensures that it takes at more time to calculate a beacon pair over
a keyset than it takes to verify it, with no amplification to bytes in flight
on an attempt to spoof.

# Example Flow

The following chart shows a flow covering initial connection to establishing
channel communication from a source to sink.

# Security

# Tools and Reference Implementations
libarcan-shmif-server, libarcan-shmif, libarcan-a12, arcan-net
afsrv\_terminal, arcan\_lwa, afsrv\_decode

# Future Changes
# Acknowledgements
# References
